##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    25/Nov/2013  17:49:16 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\iar\SVN\Elfloader3\elfloader3\srcMy\loader3\loade #
#                       lf.c                                                 #
#    Command line    =  E:\iar\SVN\Elfloader3\elfloader3\srcMy\loader3\loade #
#                       lf.c -D NDEBUG -D NEWSGOLD -D ELKA -lC               #
#                       E:\iar\SVN\Elfloader3\elfloader3\srcMy\E71sw45\List\ #
#                        -o E:\iar\SVN\Elfloader3\elfloader3\srcMy\E71sw45\O #
#                       bj\ -s9 --no_unroll --cpu_mode thumb --endian        #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None -I "E:\iar\Embedded Workbench 4.0      #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  E:\iar\SVN\Elfloader3\elfloader3\srcMy\E71sw45\List\ #
#                       loadelf.lst                                          #
#    Object file     =  E:\iar\SVN\Elfloader3\elfloader3\srcMy\E71sw45\Obj\l #
#                       oadelf.r79                                           #
#                                                                            #
#                                                                            #
##############################################################################

E:\iar\SVN\Elfloader3\elfloader3\srcMy\loader3\loadelf.c
      1          
      2          /*
      3           * Этот файл является частью программы ElfLoader
      4           * Copyright (C) 2011 by Z.Vova, Ganster
      5           * Licence: GPLv3
      6           */
      7          
      8          
      9          #include "loader.h"

  #define ELF32_ST_BIND(x)        ELF_ST_BIND(x)
          ^
"E:\iar\SVN\Elfloader3\elfloader3\srcMy\loader3\elf.h",554  Warning[Pe047]: 
          incompatible redefinition of macro "ELF32_ST_BIND" (declared at line
          356)

  #define ELF32_ST_TYPE(x)        ELF_ST_TYPE(x)
          ^
"E:\iar\SVN\Elfloader3\elfloader3\srcMy\loader3\elf.h",555  Warning[Pe047]: 
          incompatible redefinition of macro "ELF32_ST_TYPE" (declared at line
          357)
     10          
     11          // Загрузка эльфа

   \                                 In segment CODE, align 4, keep-with-next
     12          __arch Elf32_Exec* elfopen(const char* filename)
     13          {
   \                     elfopen:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
     14            int fp;
     15            Elf32_Ehdr ehdr;
     16            Elf32_Exec* ex;
     17          
     18            if((fp = fopen(filename,A_ReadOnly | A_BIN,P_READ,&ferr)) == -1) return 0;
   \   00000004   EC409FE5           LDR      R4,??elfopen_0   ;; ferr
   \   00000008   34D04DE2           SUB      SP,SP,#+52
   \   0000000C   0430A0E1           MOV      R3,R4
   \   00000010   8020A0E3           MOV      R2,#+128
   \   00000014   801CA0E3           MOV      R1,#+32768
   \   00000018   0A0000EF           SWI      +10
   \   0000001C   0050A0E1           MOV      R5,R0
   \   00000020   0060E0E3           MVN      R6,#+0
   \   00000024   060055E1           CMP      R5,R6
   \   00000028   2F00000A           BEQ      ??elfopen_1
     19          
     20            if(fread(fp, &ehdr, sizeof(Elf32_Ehdr), &ferr) == sizeof(Elf32_Ehdr))
   \   0000002C   0430A0E1           MOV      R3,R4
   \   00000030   3420A0E3           MOV      R2,#+52
   \   00000034   0D10A0E1           MOV      R1,SP
   \   00000038   0B0000EF           SWI      +11
   \   0000003C   340050E3           CMP      R0,#+52
   \   00000040   2600001A           BNE      ??elfopen_2
     21            {
     22              if( !CheckElf(&ehdr) )
   \   00000044   0D00A0E1           MOV      R0,SP
   \   00000048   ........           _BLF     CheckElf,??CheckElf??rA
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   2200001A           BNE      ??elfopen_2
     23              {
     24                ex = malloc(sizeof(Elf32_Exec));
   \   00000054   E400A0E3           MOV      R0,#+228
   \   00000058   140000EF           SWI      +20
   \   0000005C   0070B0E1           MOVS     R7,R0
     25          
     26                if(ex)
   \   00000060   1E00000A           BEQ      ??elfopen_2
     27                {
     28                  memcpy(&ex->ehdr, &ehdr, sizeof(Elf32_Ehdr));
   \   00000064   3420A0E3           MOV      R2,#+52
   \   00000068   0D10A0E1           MOV      R1,SP
   \   0000006C   080087E2           ADD      R0,R7,#+8
   \   00000070   1E0100EF           SWI      +286
     29                  ex->v_addr = (unsigned int)-1;
   \   00000074   3C6087E5           STR      R6,[R7, #+60]
     30                  ex->fp = fp;
   \   00000078   D45087E5           STR      R5,[R7, #+212]
     31                  ex->body = 0;
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   000087E5           STR      R0,[R7, #+0]
     32                  ex->type = ehdr.e_type;
                                  ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000084   F011DDE1           LDRSH    R1,[SP, #+16]
   \   00000088   4010C7E5           STRB     R1,[R7, #+64]
     33                  ex->libs = 0;
   \   0000008C   D00087E5           STR      R0,[R7, #+208]
     34                  ex->hashtab = 0;
   \   00000090   C80087E5           STR      R0,[R7, #+200]
     35                  ex->complete = 0;
   \   00000094   D800C7E5           STRB     R0,[R7, #+216]
     36          	ex->__is_ex_import = 0;
   \   00000098   D900C7E5           STRB     R0,[R7, #+217]
     37                  ex->meloaded = 0;
   \   0000009C   DC0087E5           STR      R0,[R7, #+220]
     38                  ex->switab = (int*)AddrLibrary();
   \   000000A0   FF8000EF           SWI      +33023
   \   000000A4   E00087E5           STR      R0,[R7, #+224]
     39          
     40                  if(!LoadSections(ex))
   \   000000A8   0700A0E1           MOV      R0,R7
   \   000000AC   ........           _BLF     LoadSections,??LoadSections??rA
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   0700001A           BNE      ??elfopen_3
     41                  {
     42                    ex->complete = 1;
   \   000000B8   0100A0E3           MOV      R0,#+1
   \   000000BC   D800C7E5           STRB     R0,[R7, #+216]
     43                    fclose(fp, &ferr);
   \   000000C0   0410A0E1           MOV      R1,R4
   \   000000C4   0500A0E1           MOV      R0,R5
   \   000000C8   0D0000EF           SWI      +13
     44                    return ex;
   \   000000CC   0700A0E1           MOV      R0,R7
   \   000000D0   34D08DE2           ADD      SP,SP,#+52
   \   000000D4   F080BDE8           POP      {R4-R7,PC}
     45                  }
     46                  else
     47                      elfclose(ex);
   \                     ??elfopen_3:
   \   000000D8   0700A0E1           MOV      R0,R7
   \   000000DC   ........           BL       elfclose
     48                }
     49              }
     50            }
     51          
     52            fclose(fp, &ferr);
   \                     ??elfopen_2:
   \   000000E0   0410A0E1           MOV      R1,R4
   \   000000E4   0500A0E1           MOV      R0,R5
   \   000000E8   0D0000EF           SWI      +13
     53            return 0;
   \                     ??elfopen_1:
   \   000000EC   0000A0E3           MOV      R0,#+0
   \   000000F0   34D08DE2           ADD      SP,SP,#+52
   \   000000F4   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??elfopen_0:
   \   000000F8   ........           DC32     ferr
     54          }
     55          
     56          

   \                                 In segment CODE, align 4, keep-with-next
     57          __arch void *elf_entry(Elf32_Exec *ex)
     58          {
     59              if(!ex) return 0;
   \                     elf_entry:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1EFF2F01           BXEQ     LR
     60              return ( ex->body + ex->ehdr.e_entry - ex->v_addr );
   \   00000008   3C1090E5           LDR      R1,[R0, #+60]
   \   0000000C   202090E5           LDR      R2,[R0, #+32]
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   001061E2           RSB      R1,R1,#+0
   \   00000018   000082E0           ADD      R0,R2,R0
   \   0000001C   000081E0           ADD      R0,R1,R0
   \   00000020   1EFF2FE1           BX       LR               ;; return
     61          }
     62          
     63          

   \                                 In segment CODE, align 4, keep-with-next
     64          __arch int elfclose(Elf32_Exec* ex)
     65          {
   \                     elfclose:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
     66            if(!ex) return E_EMPTY;
   \   00000008   0700A003           MOVEQ    R0,#+7
   \   0000000C   3080BD08           POPEQ    {R4,R5,PC}
     67          
     68            if(ex->complete)
   \   00000010   D800D4E5           LDRB     R0,[R4, #+216]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0800000A           BEQ      ??elfclose_0
     69              run_FINI_Array(ex);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           _BLF     run_FINI_Array,??run_FINI_Array??rA
   \   00000024   050000EA           B        ??elfclose_0
     70            // Закрываем либы
     71            while(ex->libs)
     72            {
     73              Libs_Queue* lib = ex->libs;
     74              CloseLib(lib->lib);
   \                     ??elfclose_1:
   \   00000028   000095E5           LDR      R0,[R5, #+0]
   \   0000002C   ........           _BLF     CloseLib,??CloseLib??rA
     75              ex->libs = lib->next;
   \   00000030   040095E5           LDR      R0,[R5, #+4]
   \   00000034   D00084E5           STR      R0,[R4, #+208]
     76              mfree(lib);
   \   00000038   0500A0E1           MOV      R0,R5
   \   0000003C   150000EF           SWI      +21
     77            }
   \                     ??elfclose_0:
   \   00000040   D05094E5           LDR      R5,[R4, #+208]
   \   00000044   000055E3           CMP      R5,#+0
   \   00000048   F6FFFF1A           BNE      ??elfclose_1
     78          
     79            if(ex->hashtab) mfree(ex->hashtab);
   \   0000004C   C80094E5           LDR      R0,[R4, #+200]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0000000A           BEQ      ??elfclose_2
   \   00000058   150000EF           SWI      +21
     80            if(ex->body) mfree(ex->body);
   \                     ??elfclose_2:
   \   0000005C   000094E5           LDR      R0,[R4, #+0]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0000000A           BEQ      ??elfclose_3
   \   00000068   150000EF           SWI      +21
     81            mfree(ex);
   \                     ??elfclose_3:
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   150000EF           SWI      +21
     82            return E_NO_ERROR;
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   3080BDE8           POP      {R4,R5,PC}       ;; return
     83          }
     84          
     85          

   \                                 In segment CODE, align 4, keep-with-next
     86          __arch int sub_elfclose(Elf32_Exec* ex)
     87          {
   \                     sub_elfclose:
   \   00000000   00402DE9           PUSH     {LR}
     88            //elfclose(ex);
     89            SUBPROC((void*)elfclose, ex);
   \   00000004   0010A0E1           MOV      R1,R0
   \   00000008   08009FE5           LDR      R0,??sub_elfclose_0  ;; elfclose
   \   0000000C   710100EF           SWI      +369
     90            return 0;
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   0080BDE8           POP      {PC}             ;; return
   \                     ??sub_elfclose_0:
   \   00000018   ........           DC32     elfclose
     91          }

   Maximum stack usage in bytes:

     Function     CSTACK
     --------     ------
     elf_entry        0
     elfclose        12
     elfopen         72
     sub_elfclose     4


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     elfopen         252
     elf_entry        36
     elfclose        124
     sub_elfclose     28
      Others          64

 
 504 bytes in segment CODE
 
 440 bytes of CODE memory (+ 64 bytes shared)

Errors: none
Warnings: 3
