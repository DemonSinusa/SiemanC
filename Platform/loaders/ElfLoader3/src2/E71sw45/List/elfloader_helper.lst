##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    02/Oct/2016  22:27:15 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  H:\aveman\SiemanC-git\Platform\loaders\ElfLoader3\sr #
#                       c2\elfloader_helper.c                                #
#    Command line    =  H:\aveman\SiemanC-git\Platform\loaders\ElfLoader3\sr #
#                       c2\elfloader_helper.c -D NDEBUG -D NEWSGOLD -D ELKA  #
#                       -lC H:\aveman\SiemanC-git\Platform\loaders\ElfLoader #
#                       3\src2\E71sw45\List\ -o H:\aveman\SiemanC-git\Platfo #
#                       rm\loaders\ElfLoader3\src2\E71sw45\Obj\ -s9          #
#                       --no_unroll --cpu_mode thumb --endian little --cpu   #
#                       ARM926EJ-S --stack_align 4 --interwork -e --fpu      #
#                       None -I ..\dev\include\ -I H:\aveman\IAR\ARM\INC\    #
#                       --inline_threshold=2                                 #
#    List file       =  H:\aveman\SiemanC-git\Platform\loaders\ElfLoader3\sr #
#                       c2\E71sw45\List\elfloader_helper.lst                 #
#    Object file     =  H:\aveman\SiemanC-git\Platform\loaders\ElfLoader3\sr #
#                       c2\E71sw45\Obj\elfloader_helper.r79                  #
#                                                                            #
#                                                                            #
##############################################################################

H:\aveman\SiemanC-git\Platform\loaders\ElfLoader3\src2\elfloader_helper.c
      1          #include "loader3\loader.h"
      2          #include <..\..\inc\cfg_items.h>
      3          #include "conf_loader.h"
      4          
      5          #include "loader3\env.h"
      6          
      7          #include "config_struct.h"
      8          
      9          
     10          //#define __ELFTHREAD
     11          #define ELF_PROC_RUNER_ID 0x4409

   \                                 In segment DATA_C, align 4, align-sorted
     12          const int elf_run_prio = 0x2;
   \                     elf_run_prio:
   \   00000000   02000000           DC32 2

   \                                 In segment DATA_Z, align 4, align-sorted
     13          int lock_thread = 0;
   \                     lock_thread:
   \   00000000                      DS8 4
     14          int dlclean_cache();
     15          //Mutex mutex;
     16          
     17          
     18          __arm void __run_proc(void *entry, char *filename, void *param1, void *param2, void *param3);
     19          #ifndef ARM

   \                                 In segment CODE, align 4, keep-with-next
     20          __arm void zeromem_a(void *d, int l){zeromem(d,l);}
   \                     zeromem_a:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   1D0100EF           SWI      +285
   \   00000008   0080BDE8           POP      {PC}             ;; return

   \                                 In segment CODE, align 4, keep-with-next
     21          __arm void l_msg(int a, int b) {ShowMSG(a, b);}
   \                     l_msg:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   480100EF           SWI      +328
   \   00000008   0080BDE8           POP      {PC}             ;; return
     22          #endif
     23          
     24          
     25          
     26          /* Загрузка эльфа */

   \                                 In segment CODE, align 4, keep-with-next
     27          __arch int elfload(char *filename, void *param1, void *param2, void *param3){
   \                     elfload:
   \   00000000   FFB5               PUSH     {R0-R7,LR}
     28            
     29            Elf32_Exec *ex = elfopen(filename);
     30            if(!ex){
   \   00000002   254D               LDR      R5,??elfload_0   ;; `?<Constant "Elf corrupt or missing">`
   \   00000004   C0B0               SUB      SP,SP,#+256
   \   00000006   ........           _BLF     elfopen,??elfopen??rT
   \   0000000A   0400               MOVS     R4,R0
   \   0000000C   06D1               BNE      ??elfload_1
     31              l_msg(1, (int)"Elf corrupt or missing");
   \   0000000E   2900               MOVS     R1,R5
   \   00000010   0120               MOVS     R0,#+1
   \   00000012   ........           BLX      l_msg
     32              return -1;
   \   00000016   0020               MOVS     R0,#+0
   \                     ??elfload_2:
   \   00000018   C043               MVNS     R0,R0
   \   0000001A   3BE0               B        ??elfload_3
     33            }
     34            
     35            int (*entry)(char *, void *, void*, void*) = (int (*)(char *, void *, void*, void*))elf_entry(ex);
   \                     ??elfload_1:
   \   0000001C   ........           _BLF     elf_entry,??elf_entry??rT
   \   00000020   0600               MOVS     R6,R0
     36            if(!entry){
   \   00000022   09D1               BNE      ??elfload_4
     37             l_msg(1, (int)"Entry point not found");
   \   00000024   1835               ADDS     R5,R5,#+24
   \   00000026   2900               MOVS     R1,R5
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   ........           BLX      l_msg
     38             elfclose(ex);
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           _BLF     elfclose,??elfclose??rT
     39             return -2;
   \   00000034   0120               MOVS     R0,#+1
   \   00000036   EFE7               B.N      ??elfload_2
     40            }
     41            
     42              
     43            if(!ex->__is_ex_import && ex->libs)
   \                     ??elfload_4:
   \   00000038   2700               MOVS     R7,R4
   \   0000003A   D037               ADDS     R7,R7,#+208
   \   0000003C   787A               LDRB     R0,[R7, #+9]
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   16D1               BNE      ??elfload_5
   \   00000042   3868               LDR      R0,[R7, #+0]
   \   00000044   0028               CMP      R0,#+0
   \   00000046   13D0               BEQ      ??elfload_5
     44            {
     45              l_msg(1, (int)"Incorrect elf");
   \   00000048   2900               MOVS     R1,R5
   \   0000004A   3031               ADDS     R1,R1,#+48
   \   0000004C   0120               MOVS     R0,#+1
   \   0000004E   ........           BLX      l_msg
     46              
     47              char dbg[256];
     48              int csz = sprintf(dbg, "If you wont to use the shared libraries, you must add to linker option '--defsym __ex=0' add use elfclose function!\n");
   \   00000052   4035               ADDS     R5,R5,#+64
   \   00000054   2900               MOVS     R1,R5
   \   00000056   6846               MOV      R0,SP
   \   00000058   16DF               SVC      +22
     49              ep_log(ex, dbg, csz);
   \   0000005A   0200               MOVS     R2,R0
   \   0000005C   6946               MOV      R1,SP
   \   0000005E   2000               MOVS     R0,R4
   \   00000060   ........           _BLF     ep_log,??ep_log??rT
     50              elfclose(ex);
   \   00000064   2000               MOVS     R0,R4
   \   00000066   ........           _BLF     elfclose,??elfclose??rT
     51              return -3;
   \   0000006A   0220               MOVS     R0,#+2
   \   0000006C   C043               MVNS     R0,R0
   \   0000006E   11E0               B        ??elfload_3
     52            }
     53            
     54            extern __arm void ExecuteIMB(void);
     55            ExecuteIMB();
   \                     ??elfload_5:
   \   00000070   ........           _BLF     ExecuteIMB,??ExecuteIMB??rT
     56            
     57            //run_INIT_Array(ex);
     58            entry(filename, param1, param2, param3);
   \   00000074   439B               LDR      R3,[SP, #+268]
   \   00000076   429A               LDR      R2,[SP, #+264]
   \   00000078   4199               LDR      R1,[SP, #+260]
   \   0000007A   4098               LDR      R0,[SP, #+256]
   \   0000007C   B047               BLX      R6
     59          
     60            
     61            if(!ex->__is_ex_import && !ex->libs)
   \   0000007E   787A               LDRB     R0,[R7, #+9]
   \   00000080   0028               CMP      R0,#+0
   \   00000082   06D1               BNE      ??elfload_6
   \   00000084   3868               LDR      R0,[R7, #+0]
   \   00000086   0028               CMP      R0,#+0
   \   00000088   03D1               BNE      ??elfload_6
     62            {
     63              ex->body = 0;
   \   0000008A   2060               STR      R0,[R4, #+0]
     64              elfclose(ex);
   \   0000008C   2000               MOVS     R0,R4
   \   0000008E   ........           _BLF     elfclose,??elfclose??rT
     65            }
     66            
     67          
     68            return 0;
   \                     ??elfload_6:
   \   00000092   0020               MOVS     R0,#+0
   \                     ??elfload_3:
   \   00000094   44B0               ADD      SP,SP,#+272
   \   00000096   F0BD               POP      {R4-R7,PC}       ;; return
   \                     ??elfload_0:
   \   00000098   ........           DC32     `?<Constant "Elf corrupt or missing">`
     69          }
     70          
     71          

   \                                 In segment CODE, align 4, keep-with-next
     72          __arm void InitLoaderSystem()
     73          {
   \                     InitLoaderSystem:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
     74            if(!*(config->LD_LIBRARY_PATH_env)){
   \   00000004   ........           LDR      R4,??DataTable4  ;; config
   \   00000008   38509FE5           LDR      R5,??InitLoaderSystem_0  ;; `?<Constant "LD_LIBRARY_PATH">`
   \   0000000C   000094E5           LDR      R0,[R4, #+0]
   \   00000010   E06FA0E3           MOV      R6,#+896
   \   00000014   0010D6E7           LDRB     R1,[R6, +R0]
   \   00000018   000051E3           CMP      R1,#+0
   \   0000001C   0300001A           BNE      ??InitLoaderSystem_1
     75              strncpy(config->LD_LIBRARY_PATH_env, "0:\\ZBin\\lib\\;4:\\ZBin\\lib\\;", sizeof(config->LD_LIBRARY_PATH_env));
   \   00000020   402FA0E3           MOV      R2,#+256
   \   00000024   101085E2           ADD      R1,R5,#+16
   \   00000028   000086E0           ADD      R0,R6,R0
   \   0000002C   160100EF           SWI      +278
     76            }
     77            
     78            setenv("LD_LIBRARY_PATH", config->LD_LIBRARY_PATH_env, 1);
   \                     ??InitLoaderSystem_1:
   \   00000030   000094E5           LDR      R0,[R4, #+0]
   \   00000034   0120A0E3           MOV      R2,#+1
   \   00000038   001086E0           ADD      R1,R6,R0
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   7040BDE8           POP      {R4-R6,LR}       ;; Pop
   \   00000044   ........           _BF      setenv,??setenv??rA  ;; tailcall
   \                     ??InitLoaderSystem_0:
   \   00000048   ........           DC32     `?<Constant "LD_LIBRARY_PATH">`
     79          }
     80          
     81          

   \                                 In segment CODE, align 4, keep-with-next
     82          int main()
     83          {
     84            return 0;
   \                     main:
   \   00000000   0020               MOVS     R0,#+0
   \   00000002   7047               BX       LR               ;; return
     85          }
     86          
     87          

   \                                 In segment CODE, align 4, keep-with-next
     88          int elfloader_onload(WSHDR *filename, WSHDR *ext, void *param){
   \                     elfloader_onload:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   A0B0               SUB      SP,SP,#+128
     89            char fn[128];
     90            ws_2str(filename,fn,126);
   \   00000004   6946               MOV      R1,SP
   \   00000006   1400               MOVS     R4,R2
   \   00000008   7E22               MOVS     R2,#+126
   \   0000000A   A3DF               SVC      +163
     91            if (elfload(fn, param, 0, 0)) return 0; else return 1;
   \   0000000C   0023               MOVS     R3,#+0
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   2100               MOVS     R1,R4
   \   00000012   6846               MOV      R0,SP
   \   00000014   ........           BL       elfload
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   01D0               BEQ      ??elfloader_onload_0
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   00E0               B        ??elfloader_onload_1
   \                     ??elfloader_onload_0:
   \   00000020   0120               MOVS     R0,#+1
   \                     ??elfloader_onload_1:
   \   00000022   20B0               ADD      SP,SP,#+128
   \   00000024   10BD               POP      {R4,PC}          ;; return
     92          }
     93          
     94          //=======================================================================
     95          //
     96          //=======================================================================
     97          extern void(*OldOnClose)(void *);
     98          extern void(*OldOnCreate)(void *);
     99          #ifdef NEWSGOLD
    100          extern void(*OldShowMsg)(int, int);
    101          #else
    102          extern void(*OldTxtOpen)(WSHDR*, WSHDR*);
    103          #endif
    104          
    105          extern unsigned int DEFAULT_DISK_N;
    106          
    107          //-----------------------------------------------------------------------
    108          
    109          #ifdef NEWSGOLD
    110          //#define HELPER_CEPID 0x4339
    111          #define HELPER_CEPID 0x440A
    112          #else
    113          //#define HELPER_CEPID 0x4331
    114          #define HELPER_CEPID 0x4407
    115          
    116          #endif
    117          #define MSG_HELPER_RUN 0x0001
    118          

   \                                 In segment CODE, align 4, keep-with-next
    119          __arm void proc_HELPER(void)
    120          {
   \                     proc_HELPER:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
    121            GBS_MSG msg;
    122            if (GBS_RecActDstMessage(&msg))
   \   00000008   0D00A0E1           MOV      R0,SP
   \   0000000C   530100EF           SWI      +339
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1200000A           BEQ      ??proc_HELPER_0
    123            {
    124              if (msg.msg==MSG_HELPER_RUN)
   \   00000018   04309DE5           LDR      R3,[SP, #+4]
   \   0000001C   08009DE5           LDR      R0,[SP, #+8]
   \   00000020   010053E3           CMP      R3,#+1
   \   00000024   0600001A           BNE      ??proc_HELPER_1
    125              {
    126                if (msg.data0)
   \   00000028   0C209DE5           LDR      R2,[SP, #+12]
   \   0000002C   000052E3           CMP      R2,#+0
   \   00000030   0B00000A           BEQ      ??proc_HELPER_0
    127                {
    128          	((void (*)(int, void *))(msg.data0))(msg.submess,msg.data1);
   \   00000034   10109DE5           LDR      R1,[SP, #+16]
   \   00000038   32FF2FE1           BLX      R2
   \   0000003C   14D08DE2           ADD      SP,SP,#+20
   \   00000040   0080BDE8           POP      {PC}
    129                }
    130              }
    131              else
    132              {
    133                GBS_SendMessage(MMI_CEPID,MSG_HELPER_TRANSLATOR,msg.pid_from,msg.msg,msg.submess);
   \                     ??proc_HELPER_1:
   \   00000044   01002DE9           PUSH     {R0}
   \   00000048   04209DE5           LDR      R2,[SP, #+4]
   \   0000004C   AE10A0E3           MOV      R1,#+174
   \   00000050   DE1C81E3           ORR      R1,R1,#0xDE00
   \   00000054   0900A0E3           MOV      R0,#+9
   \   00000058   420C80E3           ORR      R0,R0,#0x4200
   \   0000005C   000100EF           SWI      +256
   \   00000060   04D08DE2           ADD      SP,SP,#+4
    134              }
    135            }
    136          }
   \                     ??proc_HELPER_0:
   \   00000064   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000068   0080BDE8           POP      {PC}             ;; return
    137          

   \                                 In segment CODE, align 4, keep-with-next
    138          __arm void CreateHELPER_PROC(void)
    139          {
   \                     CreateHELPER_PROC:
   \   00000000   00402DE9           PUSH     {LR}
    140            static const char name[]="HELPER";
    141            CreateGBSproc(HELPER_CEPID, name, proc_HELPER, 0x80, 0);
   \   00000004   1C209FE5           LDR      R2,??CreateHELPER_PROC_0  ;; proc_HELPER
   \   00000008   1C109FE5           LDR      R1,??CreateHELPER_PROC_0+0x4  ;; ??name
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   01002DE9           PUSH     {R0}
   \   00000014   8030A0E3           MOV      R3,#+128
   \   00000018   0A00A0E3           MOV      R0,#+10
   \   0000001C   440C80E3           ORR      R0,R0,#0x4400
   \   00000020   050100EF           SWI      +261
    142          }
   \   00000024   0180BDE8           POP      {R0,PC}          ;; return
   \                     ??CreateHELPER_PROC_0:
   \   00000028   ........           DC32     proc_HELPER
   \   0000002C   ........           DC32     ??name

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??name:
   \   00000000   48454C504552       DC8 "HELPER"
   \              00          
   \   00000007   00                 DC8 0
    143          

   \                                 In segment CODE, align 4, keep-with-next
    144          __arm void REDRAW_impl(void)
    145          {
   \                     REDRAW_impl:
   \   00000000   00402DE9           PUSH     {LR}
    146            LockSched();
   \   00000004   460100EF           SWI      +326
    147          #ifdef NEWSGOLD
    148            PendedRedrawGUI();
   \   00000008   410100EF           SWI      +321
    149          #else
    150            PendedRedrawGUI();
    151            GBS_SendMessage(MMI_CEPID,0x90);
    152          #endif
    153            UnlockSched();
   \   0000000C   470100EF           SWI      +327
    154          }
   \   00000010   0080BDE8           POP      {PC}             ;; return
    155          

   \                                 In segment CODE, align 4, keep-with-next
    156          __arm void SUBPROC_impl(void *f, int p2, void *p1)
    157          {
   \                     SUBPROC_impl:
   \   00000000   00402DE9           PUSH     {LR}
    158            GBS_SendMessage(HELPER_CEPID,MSG_HELPER_RUN,p2,f,p1);
   \   00000004   04002DE9           PUSH     {R2}
   \   00000008   0030A0E1           MOV      R3,R0
   \   0000000C   0A00A0E3           MOV      R0,#+10
   \   00000010   440C80E3           ORR      R0,R0,#0x4400
   \   00000014   0120A0E1           MOV      R2,R1
   \   00000018   0110A0E3           MOV      R1,#+1
   \   0000001C   000100EF           SWI      +256
    159          }
   \   00000020   0180BDE8           POP      {R0,PC}          ;; return
    160          

   \                                 In segment CODE, align 4, keep-with-next
    161          __thumb void SEQKILLER_impl(void *data, void(*next_in_seq)(void *), void *data_to_kill)
    162          {
   \                     SEQKILLER_impl:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   1400               MOVS     R4,R2
    163            next_in_seq(data);
   \   00000004   8847               BLX      R1
    164            mfree(data_to_kill);
   \   00000006   2000               MOVS     R0,R4
   \   00000008   15DF               SVC      +21
    165          }
   \   0000000A   10BD               POP      {R4,PC}          ;; return
    166          

   \                                 In segment CODE, align 4, keep-with-next
    167          __arm void MyIDLECSMonClose(void *data)
    168          {
   \                     MyIDLECSMonClose:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    169            extern BXR1(void *, void (*)(void *));
    170            KillGBSproc(HELPER_CEPID);
   \   00000008   0A00A0E3           MOV      R0,#+10
   \   0000000C   440C80E3           ORR      R0,R0,#0x4400
   \   00000010   540100EF           SWI      +340
    171            dlclean_cache();
   \   00000014   ........           _BLF     dlclean_cache,??dlclean_cache??rA
    172            clearenv();
   \   00000018   ........           _BLF     clearenv,??clearenv??rA
    173            if(config)
   \   0000001C   ........           LDR      R0,??DataTable4  ;; config
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0000000A           BEQ      ??MyIDLECSMonClose_0
    174              mfree(config);
   \   0000002C   150000EF           SWI      +21
    175            
    176            BXR1(data,OldOnClose);
   \                     ??MyIDLECSMonClose_0:
   \   00000030   0C009FE5           LDR      R0,??MyIDLECSMonClose_1  ;; OldOnClose
   \   00000034   001090E5           LDR      R1,[R0, #+0]
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   1040BDE8           POP      {R4,LR}          ;; Pop
   \   00000040   ........           _BF      BXR1,??BXR1??rA  ;; tailcall
   \                     ??MyIDLECSMonClose_1:
   \   00000044   ........           DC32     OldOnClose
    177            //  OldOnClose(data);
    178            //  asm("NOP\n");
    179          }
    180          

   \                                 In segment CODE, align 4, keep-with-next
    181          __arm void LoadDaemons(void)
    182          {
    183          
    184            DIR_ENTRY de;
    185            unsigned int err;
    186            unsigned int pathlen;
    187            char name[256];
    188            strcpy(name, config->DAEMONS_FOLDER);
   \                     LoadDaemons:
   \   00000000   ........           LDR      R0,??DataTable4  ;; config
   \   00000004   10402DE9           PUSH     {R4,LR}
   \   00000008   48D04DE2           SUB      SP,SP,#+72
   \   0000000C   40DE4DE2           SUB      SP,SP,#+1024
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   7E1F80E2           ADD      R1,R0,#+504
   \   00000018   D20F8DE2           ADD      R0,SP,#+840
   \   0000001C   1A0000EF           SWI      +26
    189            //name[0]=DEFAULT_DISK_N+'0';
    190            pathlen=strlen(name);
   \   00000020   D20F8DE2           ADD      R0,SP,#+840
   \   00000024   1B0000EF           SWI      +27
    191            strcat(name,"*.elf");
   \   00000028   74109FE5           LDR      R1,??LoadDaemons_0  ;; `?<Constant "*.elf">`
   \   0000002C   0040A0E1           MOV      R4,R0
   \   00000030   D20F8DE2           ADD      R0,SP,#+840
   \   00000034   170000EF           SWI      +23
    192            if (FindFirstFile(&de,name,&err))
   \   00000038   0D20A0E1           MOV      R2,SP
   \   0000003C   D21F8DE2           ADD      R1,SP,#+840
   \   00000040   04008DE2           ADD      R0,SP,#+4
   \   00000044   6B0000EF           SWI      +107
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0E00000A           BEQ      ??LoadDaemons_1
    193            {
    194              do
    195              {
    196                //strcpy(name,path);
    197                name[pathlen]=0;
   \                     ??LoadDaemons_2:
   \   00000050   D20F8DE2           ADD      R0,SP,#+840
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   0010C4E7           STRB     R1,[R4, +R0]
    198                strcat(name,de.file_name);
   \   0000005C   B9108DE2           ADD      R1,SP,#+185
   \   00000060   170000EF           SWI      +23
    199                elfload(name,0,0,0);
   \   00000064   0030A0E3           MOV      R3,#+0
   \   00000068   0020A0E3           MOV      R2,#+0
   \   0000006C   0210A0E1           MOV      R1,R2
   \   00000070   D20F8DE2           ADD      R0,SP,#+840
   \   00000074   ........           BLX      elfload
    200              }
    201              while(FindNextFile(&de,&err));
   \   00000078   0D10A0E1           MOV      R1,SP
   \   0000007C   04008DE2           ADD      R0,SP,#+4
   \   00000080   6C0000EF           SWI      +108
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   F0FFFF1A           BNE      ??LoadDaemons_2
    202            }
    203            FindClose(&de,&err);
   \                     ??LoadDaemons_1:
   \   0000008C   0D10A0E1           MOV      R1,SP
   \   00000090   04008DE2           ADD      R0,SP,#+4
   \   00000094   6D0000EF           SWI      +109
    204          }
   \   00000098   48D08DE2           ADD      SP,SP,#+72
   \   0000009C   40DE8DE2           ADD      SP,SP,#+1024
   \   000000A0   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??LoadDaemons_0:
   \   000000A4   ........           DC32     `?<Constant "*.elf">`
    205          

   \                                 In segment DATA_N, align 4, align-sorted
    206          __no_init void *(*pLIB_TOP)[];
   \                     pLIB_TOP:
   \   00000000                      DS8 4
    207          extern void *Library[];
    208          

   \                                 In segment CODE, align 4, keep-with-next
    209          int get_file_size(const char * fname)
    210          {
   \                     get_file_size:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   8BB0               SUB      SP,SP,#+44
    211            FSTATS fs;
    212            unsigned int err;
    213            if (GetFileStats(fname,&fs,&err)==-1) return (-1);
   \   00000004   6A46               MOV      R2,SP
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   E443               MVNS     R4,R4
   \   0000000A   01A9               ADD      R1,SP,#+4
   \   0000000C   84DF               SVC      +132
   \   0000000E   A042               CMP      R0,R4
   \   00000010   01D1               BNE      ??get_file_size_0
   \   00000012   2000               MOVS     R0,R4
   \   00000014   00E0               B        ??get_file_size_1
    214            else return (fs.size);
   \                     ??get_file_size_0:
   \   00000016   0298               LDR      R0,[SP, #+8]
   \                     ??get_file_size_1:
   \   00000018   0BB0               ADD      SP,SP,#+44
   \   0000001A   10BD               POP      {R4,PC}          ;; return
    215          }
    216          

   \                                 In segment CODE, align 4, keep-with-next
    217          __arm void LoadLibrary(void)
    218          {
    219            void *(*lt)[]=pLIB_TOP;
    220          #define LIB_EMPTY ((void *)-1L)
    221            unsigned int ul;
    222            int sz;
    223            int f;
    224            char fn[64];
    225            strcpy(fn, config->SWIBLIB_WAY);
   \                     LoadLibrary:
   \   00000000   ........           LDR      R0,??DataTable4  ;; config
   \   00000004   F0402DE9           PUSH     {R4-R7,LR}
   \   00000008   38419FE5           LDR      R4,??LoadLibrary_0  ;; pLIB_TOP
   \   0000000C   78D04DE2           SUB      SP,SP,#+120
   \   00000010   005094E5           LDR      R5,[R4, #+0]
   \   00000014   000090E5           LDR      R0,[R0, #+0]
   \   00000018   A91F80E2           ADD      R1,R0,#+676
   \   0000001C   04008DE2           ADD      R0,SP,#+4
   \   00000020   1A0000EF           SWI      +26
    226            //fn[0]=DEFAULT_DISK_N+'0';
    227            if (lt)
   \   00000024   000055E3           CMP      R5,#+0
   \   00000028   0300000A           BEQ      ??LoadLibrary_1
    228            {
    229              pLIB_TOP=NULL;
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   000084E5           STR      R0,[R4, #+0]
    230              mfree(lt);
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   150000EF           SWI      +21
    231              lt=NULL;
    232            }
    233            if ((sz=get_file_size(fn))==-1) return;
   \                     ??LoadLibrary_1:
   \   0000003C   04008DE2           ADD      R0,SP,#+4
   \   00000040   ........           BLX      get_file_size
   \   00000044   0050E0E3           MVN      R5,#+0
   \   00000048   050050E1           CMP      R0,R5
   \   0000004C   3B00000A           BEQ      ??LoadLibrary_2
    234            if (sz!=16384)
   \   00000050   F4609FE5           LDR      R6,??LoadLibrary_0+0x4  ;; `?<Constant "Illegal library size!">`
   \   00000054   400C50E3           CMP      R0,#+16384
   \   00000058   0300000A           BEQ      ??LoadLibrary_3
    235            {
    236              ShowMSG(1,(int)"Illegal library size!");
   \   0000005C   0610A0E1           MOV      R1,R6
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   480100EF           SWI      +328
    237              return;
   \   00000068   190000EA           B        ??LoadLibrary_4
    238            }
    239            f=fopen(fn,A_ReadOnly+A_BIN, P_READ, &ul);
   \                     ??LoadLibrary_3:
   \   0000006C   0D30A0E1           MOV      R3,SP
   \   00000070   8020A0E3           MOV      R2,#+128
   \   00000074   801CA0E3           MOV      R1,#+32768
   \   00000078   04008DE2           ADD      R0,SP,#+4
   \   0000007C   0A0000EF           SWI      +10
   \   00000080   0070A0E1           MOV      R7,R0
    240            if (f==-1) return;
   \   00000084   050057E1           CMP      R7,R5
   \   00000088   2C00000A           BEQ      ??LoadLibrary_2
    241            lt=malloc(16384);
   \   0000008C   400CA0E3           MOV      R0,#+16384
   \   00000090   140000EF           SWI      +20
   \   00000094   0050A0E1           MOV      R5,R0
    242            if (fread(f,lt,sz,&ul)!=sz)
   \   00000098   0D30A0E1           MOV      R3,SP
   \   0000009C   402CA0E3           MOV      R2,#+16384
   \   000000A0   0510A0E1           MOV      R1,R5
   \   000000A4   0700A0E1           MOV      R0,R7
   \   000000A8   0B0000EF           SWI      +11
   \   000000AC   400C50E3           CMP      R0,#+16384
   \   000000B0   0D10A0E1           MOV      R1,SP
   \   000000B4   0700A0E1           MOV      R0,R7
   \   000000B8   0700000A           BEQ      ??LoadLibrary_5
    243            {
    244              fclose(f,&ul);
   \   000000BC   0D0000EF           SWI      +13
    245              ShowMSG(1,(int)"Can't read library!");
   \   000000C0   181086E2           ADD      R1,R6,#+24
   \                     ??LoadLibrary_6:
   \   000000C4   0100A0E3           MOV      R0,#+1
   \   000000C8   480100EF           SWI      +328
    246            LERR:
    247              mfree(lt);
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   150000EF           SWI      +21
    248              return;
   \                     ??LoadLibrary_4:
   \   000000D4   78D08DE2           ADD      SP,SP,#+120
   \   000000D8   F080BDE8           POP      {R4-R7,PC}
    249            }
    250            fclose(f,&ul);
   \                     ??LoadLibrary_5:
   \   000000DC   0D0000EF           SWI      +13
    251            f=0;
   \   000000E0   0070A0E3           MOV      R7,#+0
   \   000000E4   0700E0E1           MVN      R0,R7
    252            do
    253            {
    254              if (((*lt)[f]!=LIB_EMPTY)&&(Library[f]!=LIB_EMPTY))
   \                     ??LoadLibrary_7:
   \   000000E8   60109FE5           LDR      R1,??LoadLibrary_0+0x8  ;; Library
   \   000000EC   072195E7           LDR      R2,[R5, +R7, LSL #+2]
   \   000000F0   000052E1           CMP      R2,R0
   \   000000F4   07219117           LDRNE    R2,[R1, +R7, LSL #+2]
   \   000000F8   00005211           CMPNE    R2,R0
    255              {
    256                if ((*lt)[f]!=Library[f])
   \   000000FC   07319517           LDRNE    R3,[R5, +R7, LSL #+2]
   \   00000100   02005311           CMPNE    R3,R2
   \   00000104   0500000A           BEQ      ??LoadLibrary_8
    257                {
    258          	char s[50];
    259          	sprintf(s,"Function %d conflict!",f);
   \   00000108   0720A0E1           MOV      R2,R7
   \   0000010C   2C1086E2           ADD      R1,R6,#+44
   \   00000110   44008DE2           ADD      R0,SP,#+68
   \   00000114   160000EF           SWI      +22
    260          	ShowMSG(1,(int)s);
   \   00000118   44108DE2           ADD      R1,SP,#+68
   \   0000011C   E8FFFFEA           B        ??LoadLibrary_6
    261          	goto LERR;
    262                }
    263              }
    264              if ((*lt)[f]==LIB_EMPTY)
   \                     ??LoadLibrary_8:
   \   00000120   072195E7           LDR      R2,[R5, +R7, LSL #+2]
   \   00000124   000052E1           CMP      R2,R0
    265              {
    266                (*lt)[f]=Library[f];
   \   00000128   07119107           LDREQ    R1,[R1, +R7, LSL #+2]
   \   0000012C   07118507           STREQ    R1,[R5, +R7, LSL #+2]
    267              }
    268              f++;
   \   00000130   017087E2           ADD      R7,R7,#+1
    269            }
    270            while(f<4096);
   \   00000134   400D57E3           CMP      R7,#+4096
   \   00000138   EAFFFFBA           BLT      ??LoadLibrary_7
    271            pLIB_TOP=lt;
   \   0000013C   005084E5           STR      R5,[R4, #+0]
    272          #undef LIB_EMPTY
    273          }
   \                     ??LoadLibrary_2:
   \   00000140   78D08DE2           ADD      SP,SP,#+120      ;; stack cleaning
   \   00000144   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??LoadLibrary_0:
   \   00000148   ........           DC32     pLIB_TOP
   \   0000014C   ........           DC32     `?<Constant "Illegal library size!">`
   \   00000150   ........           DC32     Library
    274          extern void InitPngBitMap(void);
    275          

   \                                 In segment DATA_N, align 4, align-sorted
    276          __no_init char smallicons_str[32];
   \                     smallicons_str:
   \   00000000                      DS8 32
    277          __no_init char bigicons_str[32];
   \                     bigicons_str:
   \   00000020                      DS8 32
    278          
    279          
    280          #pragma segment="DATA_Z"

   \                                 In segment CODE, align 4, keep-with-next
    281          __arm void MyIDLECSMonCreate(void *data)
    282          {
    283            /* рамные сегменты с приставко Z должны обнулятся, их никто не обнулял, как оно работало вообще??? */
    284            void *must_zero = (void *)__segment_begin("DATA_Z");
    285            size_t len = (unsigned int)__segment_end("DATA_Z") - (unsigned int)__segment_begin("DATA_Z");
    286            memset(must_zero, 0, len);
   \                     MyIDLECSMonCreate:
   \   00000000   BC209FE5           LDR      R2,??MyIDLECSMonCreate_0  ;; SFE(DATA_Z) - SFB(DATA_Z)
   \   00000004   F0412DE9           PUSH     {R4-R8,LR}
    287            
    288            static const int smallicons[2]={(int)smallicons_str,0};
    289            static const int bigicons[2]={(int)bigicons_str,0};
    290            
    291          #ifdef NEWSGOLD
    292            static const REGEXPLEXT elf_reg=
    293            {
    294              "elf",
    295              0x55,
    296              0xFF,
    297              8, //Каталог Misc
    298              MENU_FLAG2,
    299              smallicons,
    300              bigicons,
    301              (int)"Open",    //LGP "Открыть"
    302              (int)"AltOpen", //LGP "Опции"
    303              LGP_DOIT_PIC,
    304              (void *)elfloader_onload,
    305              0
    306            };
    307          #else
    308            static const REGEXPLEXT elf_reg=
    309            {
    310              "elf",
    311              0x55,
    312              0xFF,
    313              7,
    314              MENU_FLAG2,
    315              smallicons,
    316              bigicons,
    317              (void *)elfloader_onload,
    318              0
    319            };
    320          #endif
    321            CreateHELPER_PROC();
    322            InitConfig();
    323            LoadLibrary();
    324            InitLoaderSystem();
    325            InitPngBitMap();
    326            //strcpy(smallicons_str+1,":\\ZBin\\img\\elf_small.png");
    327            //strcpy(bigicons_str+1,":\\ZBin\\img\\elf_big.png");
    328            //smallicons_str[0]=bigicons_str[0]=DEFAULT_DISK_N+'0';
    329            sprintf(smallicons_str, "%self_small.png", config->IMAGE_FOLDER);
   \   00000008   B8509FE5           LDR      R5,??MyIDLECSMonCreate_0+0x4  ;; smallicons_str
   \   0000000C   B8609FE5           LDR      R6,??MyIDLECSMonCreate_0+0x8  ;; `?<Constant "%self_small.png">`
   \   00000010   ........           LDR      R8,??DataTable4  ;; config
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   B0009FE5           LDR      R0,??MyIDLECSMonCreate_0+0xC  ;; SFB(DATA_Z)
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   BB0000EF           SWI      +187
   \   00000024   ........           BL       CreateHELPER_PROC
   \   00000028   ........           _BLF     InitConfig,??InitConfig??rA
   \   0000002C   ........           BL       LoadLibrary
   \   00000030   ........           BL       InitLoaderSystem
   \   00000034   ........           _BLF     InitPngBitMap,??InitPngBitMap??rA
   \   00000038   000098E5           LDR      R0,[R8, #+0]
   \   0000003C   537FA0E3           MOV      R7,#+332
   \   00000040   002087E0           ADD      R2,R7,R0
   \   00000044   0610A0E1           MOV      R1,R6
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   160000EF           SWI      +22
    330            sprintf(bigicons_str, "%self_big.png", config->IMAGE_FOLDER);
   \   00000050   000098E5           LDR      R0,[R8, #+0]
   \   00000054   101086E2           ADD      R1,R6,#+16
   \   00000058   002087E0           ADD      R2,R7,R0
   \   0000005C   200085E2           ADD      R0,R5,#+32
   \   00000060   160000EF           SWI      +22
    331            RegExplorerExt(&elf_reg);
   \   00000064   200086E2           ADD      R0,R6,#+32
   \   00000068   8C0000EF           SWI      +140
    332          
    333            /* ну а хуле, плюшки для блондинок */
    334            if( *RamPressedKey() != '#')
   \   0000006C   DF8000EF           SWI      +32991
   \   00000070   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000074   230050E3           CMP      R0,#+35
   \   00000078   0C00000A           BEQ      ??MyIDLECSMonCreate_1
    335            {
    336              if(config->load_in_suproc)
   \   0000007C   000098E5           LDR      R0,[R8, #+0]
   \   00000080   1F11D0E5           LDRB     R1,[R0, #+287]
   \   00000084   1E21D0E5           LDRB     R2,[R0, #+286]
   \   00000088   011482E1           ORR      R1,R2,R1, LSL #+8
   \   0000008C   1D21D0E5           LDRB     R2,[R0, #+285]
   \   00000090   1C01D0E5           LDRB     R0,[R0, #+284]
   \   00000094   011482E1           ORR      R1,R2,R1, LSL #+8
   \   00000098   010490E1           ORRS     R0,R0,R1, LSL #+8
   \   0000009C   0200000A           BEQ      ??MyIDLECSMonCreate_2
    337                SUBPROC((void *)LoadDaemons);
   \   000000A0   2C009FE5           LDR      R0,??MyIDLECSMonCreate_0+0x10  ;; LoadDaemons
   \   000000A4   710100EF           SWI      +369
   \   000000A8   000000EA           B        ??MyIDLECSMonCreate_1
    338              else
    339                LoadDaemons();
   \                     ??MyIDLECSMonCreate_2:
   \   000000AC   ........           BL       LoadDaemons
    340            }
    341            
    342            extern BXR1(void *, void (*)(void *));
    343            BXR1(data,OldOnCreate);
   \                     ??MyIDLECSMonCreate_1:
   \   000000B0   20009FE5           LDR      R0,??MyIDLECSMonCreate_0+0x14  ;; OldOnCreate
   \   000000B4   001090E5           LDR      R1,[R0, #+0]
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           _BLF     BXR1,??BXR1??rA
    344          
    345            //  OldOnCreate(data);
    346            //  asm("NOP\n");
    347          }
   \   000000C0   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??MyIDLECSMonCreate_0:
   \   000000C4   ........           DC32     SFE(DATA_Z) - SFB(DATA_Z)
   \   000000C8   ........           DC32     smallicons_str
   \   000000CC   ........           DC32     `?<Constant "%self_small.png">`
   \   000000D0   ........           DC32     SFB(DATA_Z)
   \   000000D4   ........           DC32     LoadDaemons
   \   000000D8   ........           DC32     OldOnCreate

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??smallicons:
   \   00000000   ........0000       DC32 smallicons_str, 0
   \              0000        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??bigicons:
   \   00000000   ........0000       DC32 bigicons_str, 0
   \              0000        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%self_small.png">`:
   \   00000000   2573656C665F       DC8 "%self_small.png"
   \              736D616C6C2E
   \              706E6700    
   \   00000010   2573656C665F       DC8 "%self_big.png"
   \              6269672E706E
   \              6700        
   \   0000001E   0000               DC8 0, 0
   \   00000020   ........5500       DC32 `?<Constant "elf">`, 85
   \              0000        
   \   00000028   FF08               DC8 255, 8
   \   0000002A   A205               DC16 1442
   \   0000002C   ............       DC32 ??smallicons, ??bigicons, `?<Constant "Open">`
   \              ............
   \   00000038   ........FBC0       DC32 `?<Constant "AltOpen">`, 2147467515, elfloader_onload, 0H
   \              FF7F........
   \              00000000    
    348          

   \                                 In segment CODE, align 4, keep-with-next
    349          unsigned int char8to16(int c)
    350          {
    351            if (c==0xA8) c=0x401;
   \                     char8to16:
   \   00000000   A828               CMP      R0,#+168
   \   00000002   01D1               BNE      ??char8to16_0
   \   00000004   1248               LDR      R0,??char8to16_1  ;; 0x401
   \   00000006   7047               BX       LR
    352            if (c==0xAA) c=0x404;
   \                     ??char8to16_0:
   \   00000008   AA28               CMP      R0,#+170
   \   0000000A   01D1               BNE      ??char8to16_2
   \   0000000C   1148               LDR      R0,??char8to16_1+0x4  ;; 0x404
   \   0000000E   7047               BX       LR
    353            if (c==0xAF) c=0x407;
   \                     ??char8to16_2:
   \   00000010   AF28               CMP      R0,#+175
   \   00000012   01D1               BNE      ??char8to16_3
   \   00000014   1048               LDR      R0,??char8to16_1+0x8  ;; 0x407
   \   00000016   7047               BX       LR
    354            if (c==0xB8) c=0x451;
   \                     ??char8to16_3:
   \   00000018   B828               CMP      R0,#+184
   \   0000001A   01D1               BNE      ??char8to16_4
   \   0000001C   0F48               LDR      R0,??char8to16_1+0xC  ;; 0x451
   \   0000001E   7047               BX       LR
    355            if (c==0xBA) c=0x454;
   \                     ??char8to16_4:
   \   00000020   BA28               CMP      R0,#+186
   \   00000022   01D1               BNE      ??char8to16_5
   \   00000024   0E48               LDR      R0,??char8to16_1+0x10  ;; 0x454
   \   00000026   7047               BX       LR
    356            if (c==0xBF) c=0x457;
   \                     ??char8to16_5:
   \   00000028   BF28               CMP      R0,#+191
   \   0000002A   01D1               BNE      ??char8to16_6
   \   0000002C   0D48               LDR      R0,??char8to16_1+0x14  ;; 0x457
   \   0000002E   7047               BX       LR
    357            if (c==0xB2) c=0x406;
   \                     ??char8to16_6:
   \   00000030   B228               CMP      R0,#+178
   \   00000032   01D1               BNE      ??char8to16_7
   \   00000034   0C48               LDR      R0,??char8to16_1+0x18  ;; 0x406
   \   00000036   7047               BX       LR
    358            if (c==0xB3) c=0x456;
   \                     ??char8to16_7:
   \   00000038   B328               CMP      R0,#+179
   \   0000003A   01D1               BNE      ??char8to16_8
   \   0000003C   0B48               LDR      R0,??char8to16_1+0x1C  ;; 0x456
   \   0000003E   7047               BX       LR
    359            if ((c>=0xC0)&&(c<0x100)) c+=0x350;
   \                     ??char8to16_8:
   \   00000040   C028               CMP      R0,#+192
   \   00000042   04DB               BLT      ??char8to16_9
   \   00000044   FF28               CMP      R0,#+255
   \   00000046   02DC               BGT      ??char8to16_9
   \   00000048   D421               MOVS     R1,#+212
   \   0000004A   8900               LSLS     R1,R1,#+2
   \   0000004C   4018               ADDS     R0,R0,R1
    360            return(c);
   \                     ??char8to16_9:
   \   0000004E   7047               BX       LR
   \                     ??char8to16_1:
   \   00000050   01040000           DC32     0x401
   \   00000054   04040000           DC32     0x404
   \   00000058   07040000           DC32     0x407
   \   0000005C   51040000           DC32     0x451
   \   00000060   54040000           DC32     0x454
   \   00000064   57040000           DC32     0x457
   \   00000068   06040000           DC32     0x406
   \   0000006C   56040000           DC32     0x456
    361          }
    362          

   \                                 In segment CODE, align 4, keep-with-next
    363          void ascii2ws(char *s, WSHDR *ws)
    364          {
   \                     ascii2ws:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   04E0               B        ??ascii2ws_0
    365            int c;
    366            while((c=*s++))
    367            {
    368              wsAppendChar(ws,char8to16(c));
   \                     ??ascii2ws_1:
   \   00000008   ........           BL       char8to16
   \   0000000C   0100               MOVS     R1,R0
   \   0000000E   2800               MOVS     R0,R5
   \   00000010   1CDF               SVC      +28
    369            }
   \                     ??ascii2ws_0:
   \   00000012   2078               LDRB     R0,[R4, #+0]
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   0028               CMP      R0,#+0
   \   00000018   F6D1               BNE      ??ascii2ws_1
    370          }
   \   0000001A   30BD               POP      {R4,R5,PC}       ;; return
    371          #ifdef NEWSGOLD

   \                                 In segment CODE, align 4, keep-with-next
    372          __arm void ESI(WSHDR *ws, int dummy, char *s)
    373          #else
    374          __arm void ESI(char *s, WSHDR *ws)
    375          #endif
    376          {
   \                     ESI:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0250A0E1           MOV      R5,R2
    377            if (((unsigned int)s>>28)==0xA) //Только строки из области RAM/FLASH
   \   0000000C   250EA0E1           LSR      R0,R5,#+28
   \   00000010   0A0050E3           CMP      R0,#+10
   \   00000014   0600001A           BNE      ??ESI_0
    378            {
    379              CutWSTR(ws,0); 
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   260100EF           SWI      +294
    380              ascii2ws(s,ws);
   \   00000024   0410A0E1           MOV      R1,R4
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           BLX      ascii2ws
   \   00000030   3080BDE8           POP      {R4,R5,PC}
    381            }
    382            else
    383            {
    384              wsprintf(ws,"|%d|",s);
   \                     ??ESI_0:
   \   00000034   08109FE5           LDR      R1,??ESI_1       ;; `?<Constant "|%d|">`
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   240100EF           SWI      +292
    385            }
    386          }
   \   00000040   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??ESI_1:
   \   00000044   ........           DC32     `?<Constant "|%d|">`
    387          
    388          /*int toupper(int c)
    389          {
    390          if ((c>='a')&&(c<='z')) c+='A'-'a';
    391          return(c);
    392          }*/
    393          
    394          //static const char extfile[]=DEFAULT_DISK ":\\ZBin\\etc\\extension.cfg";
    395          

   \                                 In segment CODE, align 4, keep-with-next
    396          __arm void DoUnknownFileType(WSHDR *filename)
    397          {
   \                     DoUnknownFileType:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    398            WSHDR *wsmime=AllocWS(15);
   \   00000008   0F00A0E3           MOV      R0,#+15
   \   0000000C   250100EF           SWI      +293
   \   00000010   0050A0E1           MOV      R5,R0
    399            wsprintf(wsmime,"txt");
   \   00000014   071F8FE2           ADR      R1,??DoUnknownFileType_0  ;; "txt"
   \   00000018   240100EF           SWI      +292
    400            ExecuteFile(filename,wsmime,0);
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   940000EF           SWI      +148
    401            FreeWS(wsmime);
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   290100EF           SWI      +297
    402          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??DoUnknownFileType_0:
   \   00000038   74787400           DC8      "txt"
    403          
    404          #ifdef NEWSGOLD 

   \                                 In segment DATA_N, align 4, align-sorted
    405          __no_init int *EXT2_AREA;
   \                     EXT2_AREA:
   \   00000000                      DS8 4
    406          #ifdef ELKA

   \                                 In segment REGEXPL_CNT, align 4, align-sorted
    407          __no_init int EXT2_CNT @ "REGEXPL_CNT";
   \                     EXT2_CNT:
   \   00000000                      DS8 4
    408          #endif
    409          
    410          #else
    411          __no_init TREGEXPLEXT *EXT2_AREA;
    412          __no_init int EXT2_CNT @ "REGEXPL_CNT";
    413          #endif
    414          
    415          #ifdef NEWSGOLD 
    416          #ifdef ELKA
    417          #else
    418          __arm int *GET_EXT2_TABLE(void)
    419          {
    420            int *p=EXT2_AREA;
    421            if (p)
    422            {
    423              return(p+1);
    424            }
    425            p=malloc(4);
    426            *p=0;
    427            return ((EXT2_AREA=p)+1);
    428          }
    429          #endif
    430          #endif  
    431          
    432          #ifdef NEWSGOLD 
    433          #ifdef ELKA

   \                                 In segment CODE, align 4, keep-with-next
    434          __arm int *EXT2_REALLOC(void)
    435          {
   \                     EXT2_REALLOC:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    436            int size;
    437            size=sizeof(REGEXPLEXT);
    438            int *p;
    439            int *p2;
    440            int n;
    441            LockSched();
    442            n=EXT2_CNT;
   \   00000004   60609FE5           LDR      R6,??EXT2_REALLOC_0  ;; EXT2_CNT
    443            p=EXT2_AREA;
   \   00000008   60709FE5           LDR      R7,??EXT2_REALLOC_0+0x4  ;; EXT2_AREA
   \   0000000C   460100EF           SWI      +326
   \   00000010   004096E5           LDR      R4,[R6, #+0]
   \   00000014   008097E5           LDR      R8,[R7, #+0]
    444            p2=malloc((n+1)*size);
   \   00000018   019084E2           ADD      R9,R4,#+1
   \   0000001C   2810A0E3           MOV      R1,#+40
   \   00000020   910900E0           MUL      R0,R1,R9
   \   00000024   140000EF           SWI      +20
   \   00000028   0050A0E1           MOV      R5,R0
    445            if (p) 
   \   0000002C   000058E3           CMP      R8,#+0
   \   00000030   0600000A           BEQ      ??EXT2_REALLOC_1
    446            {    
    447              memcpy(p2,p,n*size);
   \   00000034   2800A0E3           MOV      R0,#+40
   \   00000038   900402E0           MUL      R2,R0,R4
   \   0000003C   0810A0E1           MOV      R1,R8
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   1E0100EF           SWI      +286
    448              mfree(p);
   \   00000048   0800A0E1           MOV      R0,R8
   \   0000004C   150000EF           SWI      +21
    449            }
    450            EXT2_CNT=n+1;
   \                     ??EXT2_REALLOC_1:
   \   00000050   009086E5           STR      R9,[R6, #+0]
    451            EXT2_AREA=p2;
   \   00000054   005087E5           STR      R5,[R7, #+0]
    452            p2+=(n*(size/sizeof(int)));
    453            UnlockSched();
   \   00000058   470100EF           SWI      +327
    454            return (p2);
   \   0000005C   0A00A0E3           MOV      R0,#+10
   \   00000060   900401E0           MUL      R1,R0,R4
   \   00000064   010185E0           ADD      R0,R5,R1, LSL #+2
   \   00000068   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??EXT2_REALLOC_0:
   \   0000006C   ........           DC32     EXT2_CNT
   \   00000070   ........           DC32     EXT2_AREA
    455          }
    456          #else
    457          __arm int *EXT2_REALLOC(void)
    458          {
    459            int size;
    460            size=sizeof(REGEXPLEXT);
    461            int *p;
    462            int *p2;
    463            int n;
    464            LockSched();
    465            n=*(p=EXT2_AREA);
    466            p2=malloc((n+1)*size+4);
    467            memcpy(p2,p,n*size+4);
    468            *p2=n+1;
    469            mfree(p);
    470            EXT2_AREA=p2;
    471            p2+=(n*(size/sizeof(int)))+1;
    472            UnlockSched();
    473            return (p2);
    474          }
    475          #endif
    476          #else
    477          __arm TREGEXPLEXT *EXT2_REALLOC(void)
    478          {
    479            TREGEXPLEXT *p,*p2;
    480            int n;
    481            LockSched();
    482            n=EXT2_CNT;
    483            p=EXT2_AREA;
    484            p2=malloc((n+1)*sizeof(TREGEXPLEXT));
    485            zeromem(p2,(n+1)*sizeof(TREGEXPLEXT));
    486            if (p) 
    487            {    
    488              memcpy(p2,p,n*sizeof(TREGEXPLEXT));
    489              mfree(p);
    490            }
    491            EXT2_CNT=n+1;
    492            EXT2_AREA=p2;
    493            UnlockSched();
    494            return (p2+n);
    495          }
    496          
    497          
    498          #endif
    499          
    500          
    501          
    502          #ifdef NEWSGOLD

   \                                 In segment CODE, align 4, keep-with-next
    503          __thumb MyShowMSG(int p1, int p2)
    504          {
    505          #ifdef ELKA
    506            if (p2!=0x1DD1)
   \                     MyShowMSG:
   \   00000000   054A               LDR      R2,??MyShowMSG_0  ;; 0x1dd1
   \   00000002   00B5               PUSH     {LR}
   \   00000004   9142               CMP      R1,R2
   \   00000006   03D0               BEQ      ??MyShowMSG_1
    507          #else
    508              if (p2!=(0x1DCC+5))
    509          #endif    
    510              {
    511                OldShowMsg(p1,p2);
   \   00000008   044A               LDR      R2,??MyShowMSG_0+0x4  ;; OldShowMsg
   \   0000000A   1268               LDR      R2,[R2, #+0]
   \   0000000C   9047               BLX      R2
    512                return;
   \   0000000E   00BD               POP      {PC}
    513              }
    514            asm("MOVS R0,R6\n");
   \                     ??MyShowMSG_1:
   \   00000010   3000               MOVS R0,R6
    515            DoUnknownFileType((WSHDR *)p1);
   \   00000012   ........           BLX      DoUnknownFileType
    516          }
   \   00000016   00BD               POP      {PC}             ;; return
   \                     ??MyShowMSG_0:
   \   00000018   D11D0000           DC32     0x1dd1
   \   0000001C   ........           DC32     OldShowMsg
    517          #else
    518          
    519          __arm void PropertyPatch(WSHDR *unk_foldername, WSHDR *unk_filename)
    520          {
    521            WSHDR *ws;
    522            ws=AllocWS(255);
    523            wstrcpy(ws,unk_foldername);
    524            wsAppendChar(ws,'\\');
    525            wstrcat (ws,unk_filename);
    526            DoUnknownFileType(ws);
    527            FreeWS(ws);
    528          }
    529          
    530          #endif
    531          

   \                                 In segment CODE, align 4, keep-with-next
    532          __arm void FUNC_ABORT(int f)
    533          {
   \                     FUNC_ABORT:
   \   00000000   10402DE9           PUSH     {R4,LR}
    534            char s[32];
    535            extern void StoreErrInfoAndAbort(int code,const char *module_name,int type,int unk3);
    536            extern void StoreErrString(const char *);
    537            sprintf(s,"%d(%03X)",f,f);
   \   00000004   40409FE5           LDR      R4,??FUNC_ABORT_0  ;; `?<Constant "%d(%03X)">`
   \   00000008   20D04DE2           SUB      SP,SP,#+32
   \   0000000C   0030A0E1           MOV      R3,R0
   \   00000010   0020A0E1           MOV      R2,R0
   \   00000014   0410A0E1           MOV      R1,R4
   \   00000018   0D00A0E1           MOV      R0,SP
   \   0000001C   160000EF           SWI      +22
    538            StoreErrString(s);
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   ........           _BLF     StoreErrString,??StoreErrString??rA
    539            loopback2();
   \   00000028   020000EF           SWI      +2
    540            StoreErrInfoAndAbort(0xFFFF,"\1\1No function in lib\xA1",2,2);
   \   0000002C   0230A0E3           MOV      R3,#+2
   \   00000030   0220A0E3           MOV      R2,#+2
   \   00000034   0C1084E2           ADD      R1,R4,#+12
   \   00000038   FF00A0E3           MOV      R0,#+255
   \   0000003C   FF0C80E3           ORR      R0,R0,#0xFF00
   \   00000040   ........           _BLF     StoreErrInfoAndAbort,??StoreErrInfoAndAbort??rA
    541          }
   \   00000044   20D08DE2           ADD      SP,SP,#+32
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??FUNC_ABORT_0:
   \   0000004C   ........           DC32     `?<Constant "%d(%03X)">`
    542          
    543          //Патчи
    544          #pragma diag_suppress=Pe177

   \                                 In segment PATCH_ONCREATE, align 4, align-sorted, root
   \   00000000   ........           DC32 MyIDLECSMonCreate
    545          __root static const int NEW_ONCREATE @ "PATCH_ONCREATE" = (int)MyIDLECSMonCreate;
    546          

   \                                 In segment PATCH_ONCLOSE, align 4, align-sorted, root
   \   00000000   ........           DC32 MyIDLECSMonClose
    547          __root static const int NEW_ONCLOSE @ "PATCH_ONCLOSE" = (int)MyIDLECSMonClose;
    548          
    549          #ifdef NEWSGOLD

   \                                 In segment PATCH_SHOWMSG_BLF, align 4, align-sorted, root
   \   00000000   ........           DC32 MyShowMSG
    550          __root static const int NEW_SHOWMSG @ "PATCH_SHOWMSG_BLF" = (int)MyShowMSG;
    551          #endif
    552          

   \                                 In segment SWILIB_FUNC171, align 4, align-sorted, root
   \   00000000   ........           DC32 SUBPROC_impl
    553          __root static const int SWILIB_FUNC171 @ "SWILIB_FUNC171" = (int)SUBPROC_impl;
    554          

   \                                 In segment SWILIB_FUNC172, align 4, align-sorted, root
   \   00000000   ........           DC32 REDRAW_impl
    555          __root static const int SWILIB_FUNC172 @ "SWILIB_FUNC172" = (int)REDRAW_impl;
    556          

   \                                 In segment SWILIB_FUNC19C, align 4, align-sorted, root
   \   00000000   ........           DC32 SEQKILLER_impl

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     config

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "LD_LIBRARY_PATH">`:
   \   00000000   4C445F4C4942       DC8 "LD_LIBRARY_PATH"
   \              524152595F50
   \              41544800    
   \   00000010   303A5C5A4269       DC8 "0:\\ZBin\\lib\\;4:\\ZBin\\lib\\;"
   \              6E5C6C69625C
   \              3B343A5C5A42
   \              696E5C6C6962
   \              5C3B00      
   \   0000002B   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "*.elf">`:
   \   00000000   2A2E656C6600       DC8 "*.elf"
   \   00000006   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Illegal library size!">`:
   \   00000000   496C6C656761       DC8 "Illegal library size!"
   \              6C206C696272
   \              617279207369
   \              7A652100    
   \   00000016   0000               DC8 0, 0
   \   00000018   43616E277420       DC8 "Can't read library!"
   \              72656164206C
   \              696272617279
   \              2100        
   \   0000002C   46756E637469       DC8 "Function %d conflict!"
   \              6F6E20256420
   \              636F6E666C69
   \              63742100    
   \   00000042   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "elf">`:
   \   00000000   656C6600           DC8 "elf"

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Open">`:
   \   00000000   4F70656E00         DC8 "Open"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "AltOpen">`:
   \   00000000   416C744F7065       DC8 "AltOpen"
   \              6E00        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "|%d|">`:
   \   00000000   7C25647C00         DC8 "|%d|"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   74787400           DC8 "txt"

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%d(%03X)">`:
   \   00000000   256428253033       DC8 "%d(%03X)"
   \              582900      
   \   00000009   000000             DC8 0, 0, 0
   \   0000000C   01014E6F2066       DC8 "\001\001No function in lib\241"
   \              756E6374696F
   \              6E20696E206C
   \              6962A100    
   \   00000022   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Elf corrupt or missing">`:
   \   00000000   456C6620636F       DC8 "Elf corrupt or missing"
   \              727275707420
   \              6F72206D6973
   \              73696E6700  
   \   00000017   00                 DC8 0
   \   00000018   456E74727920       DC8 "Entry point not found"
   \              706F696E7420
   \              6E6F7420666F
   \              756E6400    
   \   0000002E   0000               DC8 0, 0
   \   00000030   496E636F7272       DC8 "Incorrect elf"
   \              65637420656C
   \              6600        
   \   0000003E   0000               DC8 0, 0
   \   00000040   496620796F75       DC8 49H, 66H, 20H, 79H, 6FH, 75H, 20H, 77H
   \              2077        
   \   00000048   6F6E7420746F       DC8 6FH, 6EH, 74H, 20H, 74H, 6FH, 20H, 75H
   \              2075        
   \   00000050   736520746865       DC8 73H, 65H, 20H, 74H, 68H, 65H, 20H, 73H
   \              2073        
   \   00000058   686172656420       DC8 68H, 61H, 72H, 65H, 64H, 20H, 6CH, 69H
   \              6C69        
   \   00000060   627261726965       DC8 62H, 72H, 61H, 72H, 69H, 65H, 73H, 2CH
   \              732C        
   \   00000068   20796F75206D       DC8 20H, 79H, 6FH, 75H, 20H, 6DH, 75H, 73H
   \              7573        
   \   00000070   742061646420       DC8 74H, 20H, 61H, 64H, 64H, 20H, 74H, 6FH
   \              746F        
   \   00000078   206C696E6B65       DC8 20H, 6CH, 69H, 6EH, 6BH, 65H, 72H, 20H
   \              7220        
   \   00000080   6F7074696F6E       DC8 6FH, 70H, 74H, 69H, 6FH, 6EH, 20H, 27H
   \              2027        
   \   00000088   2D2D64656673       DC8 2DH, 2DH, 64H, 65H, 66H, 73H, 79H, 6DH
   \              796D        
   \   00000090   205F5F65783D       DC8 20H, 5FH, 5FH, 65H, 78H, 3DH, 30H, 27H
   \              3027        
   \   00000098   206164642075       DC8 20H, 61H, 64H, 64H, 20H, 75H, 73H, 65H
   \              7365        
   \   000000A0   20656C66636C       DC8 20H, 65H, 6CH, 66H, 63H, 6CH, 6FH, 73H
   \              6F73        
   \   000000A8   652066756E63       DC8 65H, 20H, 66H, 75H, 6EH, 63H, 74H, 69H
   \              7469        
   \   000000B0   6F6E210A00         DC8 6FH, 6EH, 21H, 0AH, 0
   \   000000B5   000000             DC8 0, 0, 0
    557          __root static const int SWILIB_FUNC19C @ "SWILIB_FUNC19C" = (int)SEQKILLER_impl;
    558          #pragma diag_default=Pe177
    559          
    560          

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     CreateHELPER_PROC     8
     DoUnknownFileType    12
     ESI                  12
     EXT2_REALLOC         28
     FUNC_ABORT           40
     InitLoaderSystem     16
     LoadDaemons        1104
     LoadLibrary         140
     MyIDLECSMonClose      8
     MyIDLECSMonCreate    24
     MyShowMSG             4
     REDRAW_impl           4
     SEQKILLER_impl        8
     SUBPROC_impl          8
     ascii2ws             12
     char8to16             4
     elfload             292
     elfloader_onload    136
     get_file_size        52
     l_msg                 4
     main                  0
     proc_HELPER          28
     zeromem_a             4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     elf_run_prio                      4
     lock_thread                       4
     zeromem_a                        12
     l_msg                            12
     elfload                         156
     InitLoaderSystem                 76
     main                              4
     elfloader_onload                 38
     proc_HELPER                     108
     CreateHELPER_PROC                48
     name                              8
     REDRAW_impl                      20
     SUBPROC_impl                     36
     SEQKILLER_impl                   12
     MyIDLECSMonClose                 72
     LoadDaemons                     168
     pLIB_TOP                          4
     get_file_size                    28
     LoadLibrary                     340
     smallicons_str                   64
     MyIDLECSMonCreate               220
     smallicons                        8
     bigicons                          8
     ?<Constant "%self_small.png">    72
     char8to16                       112
     ascii2ws                         28
     ESI                              72
     DoUnknownFileType                60
     EXT2_AREA                         4
     EXT2_CNT                          4
     EXT2_REALLOC                    116
     MyShowMSG                        32
     FUNC_ABORT                       80
     NEW_ONCREATE                      4
     NEW_ONCLOSE                       4
     NEW_SHOWMSG                       4
     SWILIB_FUNC171                    4
     SWILIB_FUNC172                    4
     SWILIB_FUNC19C                    4
     ??DataTable4                      4
     ?<Constant "LD_LIBRARY_PATH">    44
     ?<Constant "*.elf">               8
     ?<Constant "Illegal library size!">
                                      68
     ?<Constant "elf">                 4
     ?<Constant "Open">                8
     ?<Constant "AltOpen">             8
     ?<Constant "|%d|">                8
     ?<Constant "txt">                 4
     ?<Constant "%d(%03X)">           36
     ?<Constant "Elf corrupt or missing">
                                     184
      Others                         272

 
 2 114 bytes in segment CODE
   472 bytes in segment DATA_C
    72 bytes in segment DATA_N
     4 bytes in segment DATA_Z
    12 bytes in segment INITTAB
     4 bytes in segment PATCH_ONCLOSE
     4 bytes in segment PATCH_ONCREATE
     4 bytes in segment PATCH_SHOWMSG_BLF
     4 bytes in segment REGEXPL_CNT
     4 bytes in segment SWILIB_FUNC171
     4 bytes in segment SWILIB_FUNC172
     4 bytes in segment SWILIB_FUNC19C
 
 1 854 bytes of CODE  memory (+ 272 bytes shared)
   496 bytes of CONST memory
    80 bytes of DATA  memory

Errors: none
Warnings: none
